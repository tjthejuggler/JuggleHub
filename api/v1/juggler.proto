syntax = "proto3";
package juggler.v1;

// 3D vector for positions, velocities, accelerations
message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

// 2D vector for pixel coordinates
message Vector2 {
  double x = 1;
  double y = 2;
}

// Color information in BGR format
message Color {
  uint32 b = 1;  // Blue component (0-255)
  uint32 g = 2;  // Green component (0-255)
  uint32 r = 3;  // Red component (0-255)
}

// HSV color range for ball detection
message HSVRange {
  Vector3 min_hsv = 1;  // Minimum HSV values
  Vector3 max_hsv = 2;  // Maximum HSV values
}

// Ball detection and tracking information
message Ball {
  string id = 1;                    // Unique ball identifier
  string color_name = 2;            // Color name (pink, orange, green, yellow)
  Vector3 position_3d = 3;          // 3D position in meters (camera coordinates)
  Vector2 position_2d = 4;          // 2D pixel position in image
  Vector3 velocity_3d = 5;          // 3D velocity in m/s
  double radius_px = 6;             // Radius in pixels
  double depth_m = 7;               // Depth in meters
  Color color_bgr = 8;              // Detected color in BGR
  double confidence = 9;            // Detection confidence (0.0-1.0)
  bool is_held = 10;                // Whether ball is being held (hand tracking)
  uint64 timestamp_us = 11;         // Timestamp in microseconds
  HSVRange color_range = 12;        // HSV color range used for detection
}

// Hand position and tracking
message Hand {
  string side = 1;                  // "left" or "right"
  Vector2 position_2d = 2;          // 2D pixel position
  Vector3 position_3d = 3;          // 3D position if available
  double confidence = 4;            // Detection confidence (0.0-1.0)
  bool is_visible = 5;              // Whether hand is visible
}

// IMU data from smartwatches
message IMUData {
  string watch_name = 1;            // Watch identifier
  string watch_ip = 2;              // Watch IP address
  Vector3 acceleration = 3;         // Acceleration in m/sÂ²
  Vector3 gyroscope = 4;            // Angular velocity in rad/s
  Vector3 magnetometer = 5;         // Magnetic field (if available)
  double accel_magnitude = 6;       // Acceleration magnitude
  double gyro_magnitude = 7;        // Gyroscope magnitude
  uint64 timestamp_us = 8;          // Timestamp in microseconds
  double data_age_ms = 9;           // Age of data in milliseconds
}

// Camera intrinsics for 3D calculations
message CameraIntrinsics {
  double fx = 1;                    // Focal length X
  double fy = 2;                    // Focal length Y
  double ppx = 3;                   // Principal point X
  double ppy = 4;                   // Principal point Y
  double depth_scale = 5;           // Depth scale factor
}

// System status and diagnostics
message SystemStatus {
  bool camera_connected = 1;        // Camera connection status
  bool engine_running = 2;          // Engine process status
  double fps = 3;                   // Current FPS
  uint32 frame_count = 4;           // Total frames processed
  string mode = 5;                  // Current mode (live, playback, etc.)
  string error_message = 6;         // Error message if any
  uint64 timestamp_us = 7;          // Status timestamp
}

// Main frame data packet sent from engine to hub
message FrameData {
  uint64 timestamp_us = 1;          // Frame timestamp in microseconds
  repeated Ball balls = 2;          // Detected and tracked balls
  repeated Hand hands = 3;          // Detected hands
  repeated IMUData imu_data = 4;    // IMU data from watches
  CameraIntrinsics intrinsics = 5;  // Camera intrinsics
  SystemStatus status = 6;          // System status
  
  // Frame metadata
  uint32 frame_width = 7;           // Frame width in pixels
  uint32 frame_height = 8;          // Frame height in pixels
  uint32 frame_number = 9;          // Sequential frame number
  
  // Optional image data (base64 encoded for streaming)
  string color_image_b64 = 10;      // Base64 encoded color image
  string depth_image_b64 = 11;      // Base64 encoded depth image
}

// Command and control API for managing engine modules
message CommandRequest {
  enum CommandType {
    UNKNOWN = 0;
    LOAD_MODULE = 1;
    UNLOAD_MODULE = 2;
    SEND_COLOR_COMMAND = 3;
  }
  
  CommandType type = 1;
  string module_name = 2;           // Name of the module to load/unload
  uint64 timestamp_us = 3;          // Command timestamp
  ColorCommand color_command = 4;
  map<string, string> module_args = 5; // Arguments for the module
}

message ColorCommand {
  string ball_id = 1;
  Color color = 2;
}

message CommandResponse {
  bool success = 1;                 // Whether the command was successful
  string message = 2;               // Response message (e.g., error details)
  uint64 timestamp_us = 3;          // Response timestamp
}